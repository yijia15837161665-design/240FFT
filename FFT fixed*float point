import math

class FixedPoint:
    """定点数类，使用16位整数部分，16位小数部分"""
    def __init__(self, value, is_fixed=False):
        if is_fixed:
            self.fixed_val = value
        else:
            # 转换为定点：左移16位
            self.fixed_val = int(value * (1 << 16))
    
    def to_float(self):
        return self.fixed_val / (1 << 16)
    
    def __add__(self, other):
        if isinstance(other, FixedPoint):
            return FixedPoint(self.fixed_val + other.fixed_val, True)
        else:
            return FixedPoint(self.fixed_val + int(other * (1 << 16)), True)
    
    def __sub__(self, other):
        if isinstance(other, FixedPoint):
            return FixedPoint(self.fixed_val - other.fixed_val, True)
        else:
            return FixedPoint(self.fixed_val - int(other * (1 << 16)), True)
    
    def __mul__(self, other):
        if isinstance(other, FixedPoint):
            # 定点乘法需要右移16位避免溢出
            result = (self.fixed_val * other.fixed_val) >> 16
            return FixedPoint(result, True)
        else:
            result = (self.fixed_val * int(other * (1 << 16))) >> 16
            return FixedPoint(result, True)
    
    def __neg__(self):
        return FixedPoint(-self.fixed_val, True)

class ComplexNum:
    """复数类，支持浮点和定点运算"""
    def __init__(self, real, imag, use_fixed=False):
        if use_fixed:
            self.real = FixedPoint(real) if not isinstance(real, FixedPoint) else real
            self.imag = FixedPoint(imag) if not isinstance(imag, FixedPoint) else imag
            self.is_fixed = True
        else:
            self.real = real
            self.imag = imag
            self.is_fixed = False
    
    def __add__(self, other):
        if self.is_fixed:
            return ComplexNum(self.real + other.real, self.imag + other.imag, True)
        else:
            return ComplexNum(self.real + other.real, self.imag + other.imag, False)
    
    def __sub__(self, other):
        if self.is_fixed:
            return ComplexNum(self.real - other.real, self.imag - other.imag, True)
        else:
            return ComplexNum(self.real - other.real, self.imag - other.imag, False)
    
    def __mul__(self, other):
        if self.is_fixed:
            # 复数乘法: (a+bi)(c+di) = (ac-bd) + (ad+bc)i
            real_part = self.real * other.real - self.imag * other.imag
            imag_part = self.real * other.imag + self.imag * other.real
            return ComplexNum(real_part, imag_part, True)
        else:
            real_part = self.real * other.real - self.imag * other.imag
            imag_part = self.real * other.imag + self.imag * other.real
            return ComplexNum(real_part, imag_part, False)
    
    def to_float_tuple(self):
        if self.is_fixed:
            return (self.real.to_float(), self.imag.to_float())
        else:
            return (self.real, self.imag)

class FFT240:
    def __init__(self, use_fixed_point=False):
        self.use_fixed = use_fixed_point
        self.twiddle_factors = self._precompute_twiddles()
        
    def _precompute_twiddles(self):
        """预计算旋转因子"""
        twiddles = {}
        
        # 为不同大小预计算旋转因子
        sizes = [2, 3, 5, 15, 16, 240]
        for N in sizes:
            twiddles[N] = []
            for k in range(N):
                angle = -2.0 * math.pi * k / N
                cos_val = math.cos(angle)
                sin_val = math.sin(angle)
                twiddles[N].append(ComplexNum(cos_val, sin_val, self.use_fixed))
        
        return twiddles
    
    def _radix2_butterfly(self, x0, x1, twiddle):
        """基-2蝶形运算"""
        temp = x1 * twiddle
        y0 = x0 + temp
        y1 = x0 - temp
        return y0, y1
    
    def _radix3_butterfly(self, x0, x1, x2, w1, w2):
        """基-3蝶形运算"""
        t1 = x1 * w1
        t2 = x2 * w2
        
        # 第一个输出
        y0 = x0 + t1 + t2
        
        # 基-3的系数
        c1 = -0.5  # cos(2π/3)
        s1 = 0.866025403784  # sin(2π/3)
        
        if self.use_fixed:
            c1_fixed = FixedPoint(c1)
            s1_fixed = FixedPoint(s1)
            
            # y1 = x0 + c1*(t1 + t2) + j*s1*(t1 - t2)
            temp_sum = t1 + t2
            temp_diff = t1 - t2
            
            real_y1 = x0.real + temp_sum.real * c1_fixed - temp_diff.imag * s1_fixed
            imag_y1 = x0.imag + temp_sum.imag * c1_fixed + temp_diff.real * s1_fixed
            
            # y2 = x0 + c1*(t1 + t2) - j*s1*(t1 - t2)  
            real_y2 = x0.real + temp_sum.real * c1_fixed + temp_diff.imag * s1_fixed
            imag_y2 = x0.imag + temp_sum.imag * c1_fixed - temp_diff.real * s1_fixed
            
            y1 = ComplexNum(real_y1, imag_y1, True)
            y2 = ComplexNum(real_y2, imag_y2, True)
        else:
            temp_sum = t1 + t2
            temp_diff = t1 - t2
            
            real_y1 = x0.real + temp_sum.real * c1 - temp_diff.imag * s1
            imag_y1 = x0.imag + temp_sum.imag * c1 + temp_diff.real * s1
            
            real_y2 = x0.real + temp_sum.real * c1 + temp_diff.imag * s1
            imag_y2 = x0.imag + temp_sum.imag * c1 - temp_diff.real * s1
            
            y1 = ComplexNum(real_y1, imag_y1, False)
            y2 = ComplexNum(real_y2, imag_y2, False)
            
        return y0, y1, y2
    
    def _radix5_butterfly(self, inputs, twiddles):
        """基-5蝶形运算"""
        x0, x1, x2, x3, x4 = inputs
        w1, w2, w3, w4 = twiddles
        
        # 旋转输入
        t1 = x1 * w1
        t2 = x2 * w2
        t3 = x3 * w3
        t4 = x4 * w4
        
        # 基-5 DFT系数
        c1 = 0.309016994374947   # cos(2π/5)
        c2 = -0.809016994374947  # cos(4π/5)
        s1 = 0.951056516295154   # sin(2π/5)
        s2 = 0.587785252292473   # sin(4π/5)
        
        if self.use_fixed:
            c1, c2 = FixedPoint(c1), FixedPoint(c2)
            s1, s2 = FixedPoint(s1), FixedPoint(s2)
        
        # 输出计算
        y0 = x0 + t1 + t2 + t3 + t4
        
        # 中间变量
        a1 = t1 + t4
        a2 = t2 + t3
        b1 = t1 - t4
        b2 = t2 - t3
        
        if self.use_fixed:
            real_base = x0.real + a1.real * c1 + a2.real * c2
            imag_base = x0.imag + a1.imag * c1 + a2.imag * c2
            
            # y1
            real_y1 = real_base - b1.imag * s1 - b2.imag * s2
            imag_y1 = imag_base + b1.real * s1 + b2.real * s2
            y1 = ComplexNum(real_y1, imag_y1, True)
            
            # y2  
            real_y2 = x0.real + a1.real * c2 + a2.real * c1
            imag_y2 = x0.imag + a1.imag * c2 + a2.imag * c1
            real_y2 = real_y2 - b1.imag * s2 + b2.imag * s1
            imag_y2 = imag_y2 + b1.real * s2 - b2.real * s1
            y2 = ComplexNum(real_y2, imag_y2, True)
            
            # y3 (y2的共轭对称)
            real_y3 = x0.real + a1.real * c2 + a2.real * c1
            imag_y3 = x0.imag + a1.imag * c2 + a2.imag * c1
            real_y3 = real_y3 + b1.imag * s2 - b2.imag * s1
            imag_y3 = imag_y3 - b1.real * s2 + b2.real * s1
            y3 = ComplexNum(real_y3, imag_y3, True)
            
            # y4 (y1的共轭对称)
            real_y4 = x0.real + a1.real * c1 + a2.real * c2
            imag_y4 = x0.imag + a1.imag * c1 + a2.imag * c2
            real_y4 = real_y4 + b1.imag * s1 + b2.imag * s2
            imag_y4 = imag_y4 - b1.real * s1 - b2.real * s2
            y4 = ComplexNum(real_y4, imag_y4, True)
            
        else:
            real_base = x0.real + a1.real * c1 + a2.real * c2
            imag_base = x0.imag + a1.imag * c1 + a2.imag * c2
            
            real_y1 = real_base - b1.imag * s1 - b2.imag * s2
            imag_y1 = imag_base + b1.real * s1 + b2.real * s2
            y1 = ComplexNum(real_y1, imag_y1, False)
            
            real_y2 = x0.real + a1.real * c2 + a2.real * c1
            imag_y2 = x0.imag + a1.imag * c2 + a2.imag * c1
            real_y2 = real_y2 - b1.imag * s2 + b2.imag * s1
            imag_y2 = imag_y2 + b1.real * s2 - b2.real * s1
            y2 = ComplexNum(real_y2, imag_y2, False)
            
            real_y3 = x0.real + a1.real * c2 + a2.real * c1
            imag_y3 = x0.imag + a1.imag * c2 + a2.imag * c1
            real_y3 = real_y3 + b1.imag * s2 - b2.imag * s1
            imag_y3 = imag_y3 - b1.real * s2 + b2.real * s1
            y3 = ComplexNum(real_y3, imag_y3, False)
            
            real_y4 = x0.real + a1.real * c1 + a2.real * c2
            imag_y4 = x0.imag + a1.imag * c1 + a2.imag * c2
            real_y4 = real_y4 + b1.imag * s1 + b2.imag * s2
            imag_y4 = imag_y4 - b1.real * s1 - b2.real * s2
            y4 = ComplexNum(real_y4, imag_y4, False)
            
        return y0, y1, y2, y3, y4
    
    def _mixed_radix_reorder(self, data):
        """混合基重排序：240 = 16 × 15"""
        n = len(data)
        result = [None] * n
        
        # 240 = 16 × 15 的重排序
        for i in range(16):
            for j in range(15):
                old_idx = i * 15 + j
                new_idx = j * 16 + i
                if old_idx < n and new_idx < n:
                    result[new_idx] = data[old_idx]
                    
        return result
    
    def _radix16_stage(self, x):
        """基-16阶段（4个基-2阶段）"""
        n = len(x)
        
        # 第1个基-2阶段
        for i in range(0, n, 2):
            if i + 1 < n:
                twiddle = self.twiddle_factors[2][0]  # W_2^0 = 1
                x[i], x[i + 1] = self._radix2_butterfly(x[i], x[i + 1], twiddle)
        
        # 第2个基-2阶段  
        for i in range(0, n, 4):
            for j in range(2):
                if i + j + 2 < n:
                    twiddle_idx = j
                    twiddle = self.twiddle_factors[240][twiddle_idx * 240 // 4]
                    x[i + j], x[i + j + 2] = self._radix2_butterfly(x[i + j], x[i + j + 2], twiddle)
        
        # 第3个基-2阶段
        for i in range(0, n, 8):
            for j in range(4):
                if i + j + 4 < n:
                    twiddle_idx = j
                    twiddle = self.twiddle_factors[240][twiddle_idx * 240 // 8]
                    x[i + j], x[i + j + 4] = self._radix2_butterfly(x[i + j], x[i + j + 4], twiddle)
        
        # 第4个基-2阶段
        for i in range(0, n, 16):
            for j in range(8):
                if i + j + 8 < n:
                    twiddle_idx = j
                    twiddle = self.twiddle_factors[240][twiddle_idx * 240 // 16]
                    x[i + j], x[i + j + 8] = self._radix2_butterfly(x[i + j], x[i + j + 8], twiddle)
        
        return x
    
    def _radix15_stage(self, x):
        """基-15阶段（基-3 × 基-5）"""
        n = len(x)
        
        # 先做基-3变换，每组5个元素
        for group in range(0, n, 15):
            for subgroup in range(5):
                indices = [group + subgroup, group + subgroup + 5, group + subgroup + 10]
                if all(idx < n for idx in indices):
                    # 基-3蝶形运算
                    w1 = self.twiddle_factors[15][subgroup]
                    w2 = self.twiddle_factors[15][(2 * subgroup) % 15]
                    
                    x[indices[0]], x[indices[1]], x[indices[2]] = self._radix3_butterfly(
                        x[indices[0]], x[indices[1]], x[indices[2]], w1, w2)
        
        # 再做基-5变换，每组3个元素  
        for group in range(0, n, 15):
            for subgroup in range(3):
                indices = []
                for k in range(5):
                    idx = group + subgroup * 5 + k
                    if idx < n:
                        indices.append(idx)
                
                if len(indices) == 5:
                    # 基-5蝶形运算
                    twiddles = []
                    for k in range(1, 5):
                        twiddle_idx = (k * subgroup) % 15
                        twiddles.append(self.twiddle_factors[15][twiddle_idx])
                    
                    inputs = [x[idx] for idx in indices]
                    outputs = self._radix5_butterfly(inputs, twiddles)
                    
                    for k, idx in enumerate(indices):
                        x[idx] = outputs[k]
        
        return x
    
    def _apply_twiddle_factors(self, x):
        """应用中间旋转因子"""
        n = len(x)
        
        # 在16点和15点变换之间应用旋转因子
        for i in range(n):
            # 计算二维索引
            i1 = i // 15  # 0 to 15
            i2 = i % 15   # 0 to 14
            
            # 计算旋转因子索引
            twiddle_idx = (i1 * i2) % 240
            twiddle = self.twiddle_factors[240][twiddle_idx]
            
            x[i] = x[i] * twiddle
            
        return x
    
    def compute_fft(self, data):
        """主FFT计算函数 - 240 = 16 × 15"""
        if len(data) != 240:
            raise ValueError("输入数据长度必须为240")
        
        # 转换输入为复数
        x = [ComplexNum(val.real if hasattr(val, 'real') else val,
                       val.imag if hasattr(val, 'imag') else 0, self.use_fixed) for val in data]
        
        # 第一步：混合基重排序
        x = self._mixed_radix_reorder(x)
        
        # 第二步：16点FFT（4个基-2阶段）
        x = self._radix16_stage(x)
        
        # 第三步：应用中间旋转因子
        x = self._apply_twiddle_factors(x)
        
        # 第四步：15点FFT（基-3 × 基-5）
        x = self._radix15_stage(x)
        
        return x

# 验证函数：简单DFT作为参考
def simple_dft(data):
    """简单DFT实现用于验证"""
    N = len(data)
    result = []
    
    for k in range(N):
        sum_real = 0.0
        sum_imag = 0.0
        
        for n in range(N):
            angle = -2.0 * math.pi * k * n / N
            cos_val = math.cos(angle)
            sin_val = math.sin(angle)
            
            if hasattr(data[n], 'real'):
                real_part = data[n].real
                imag_part = data[n].imag
            else:
                real_part = data[n]
                imag_part = 0.0
            
            # 复数乘法
            sum_real = sum_real + real_part * cos_val - imag_part * sin_val
            sum_imag = sum_imag + real_part * sin_val + imag_part * cos_val
        
        result.append(ComplexNum(sum_real, sum_imag, False))
    
    return result

# 测试程序
def test_fft():
    print("测试240点完整混合基FFT实现")
    
    # 生成测试数据：包含多个频率分量
    test_data = []
    for i in range(240):
        # 复合信号：直流 + 基频 + 谐波
        val = 1.0 + 0.5 * math.cos(2 * math.pi * i / 240) + 0.3 * math.cos(2 * math.pi * 3 * i / 240)
        test_data.append(val)
    
    # 使用简单DFT作为参考
    print("\n计算参考DFT...")
    reference_result = simple_dft(test_data[:10])  # 只计算前10点作为参考
    
    # 浮点FFT测试
    print("\n=== 浮点FFT测试 ===")
    fft_float = FFT240(use_fixed_point=False)
    result_float = fft_float.compute_fft(test_data)
    
    print("前10个浮点FFT结果:")
    for i in range(10):
        real, imag = result_float[i].to_float_tuple()
        magnitude = (real**2 + imag**2)**0.5
        print(f"X[{i}] = {real:.6f} + {imag:.6f}j, |X[{i}]| = {magnitude:.6f}")
    
    # 定点FFT测试
    print("\n=== 定点FFT测试 ===")
    fft_fixed = FFT240(use_fixed_point=True)
    result_fixed = fft_fixed.compute_fft(test_data)
    
    print("前10个定点FFT结果:")
    for i in range(10):
        real, imag = result_fixed[i].to_float_tuple()
        magnitude = (real**2 + imag**2)**0.5
        print(f"X[{i}] = {real:.6f} + {imag:.6f}j, |X[{i}]| = {magnitude:.6f}")
    
    # 与参考DFT对比（前10点）
    print("\n=== 与参考DFT对比 ===")
    print("参考DFT结果:")
    for i in range(10):
        real, imag = reference_result[i].to_float_tuple()
        magnitude = (real**2 + imag**2)**0.5
        print(f"DFT[{i}] = {real:.6f} + {imag:.6f}j, |DFT[{i}]| = {magnitude:.6f}")
    
    # 误差分析
    print("\n=== 误差分析 ===")
    float_errors = []
    fixed_errors = []
    
    for i in range(10):
        ref_real, ref_imag = reference_result[i].to_float_tuple()
        float_real, float_imag = result_float[i].to_float_tuple()
        fixed_real, fixed_imag = result_fixed[i].to_float_tuple()
        
        float_error = ((float_real - ref_real)**2 + (float_imag - ref_imag)**2)**0.5
        fixed_error = ((fixed_real - ref_real)**2 + (fixed_imag - ref_imag)**2)**0.5
        
        float_errors.append(float_error)
        fixed_errors.append(fixed_error)
        
        print(f"误差[{i}]: 浮点={float_error:.8f}, 定点={fixed_error:.8f}")
    
    print(f"\n最大误差: 浮点={max(float_errors):.8f}, 定点={max(fixed_errors):.8f}")
    print(f"平均误差: 浮点={sum(float_errors)/len(float_errors):.8f}, 定点={sum(fixed_errors)/len(fixed_errors):.8f}")
    
    # 频谱分析
    print("\n=== 频谱峰值检测 ===")
    magnitudes = []
    for i in range(240):
        real, imag = result_float[i].to_float_tuple()
        mag = (real**2 + imag**2)**0.5
        magnitudes.append(mag)
    
    # 找出最大的几个峰值
    peaks = []
    for i in range(240):
        if magnitudes[i] > 10.0:  # 阈值
            peaks.append((i, magnitudes[i]))
    
    peaks.sort(key=lambda x: x[1], reverse=True)
    print("检测到的频谱峰值:")
    for freq, mag in peaks[:5]:
        print(f"频率bin {freq}: 幅度 = {mag:.2f}")

if __name__ == "__main__":
    test_fft()
